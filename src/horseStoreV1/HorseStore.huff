// takes -> what it takes from the stack & returns -> what it gives to the stack

/*Interface*/

#define function updateHorseNumber(uint256) nonpayable returns()
#define function readNumberOfHorses() view returns(uint256)

// top[]bottom {stack}
#define macro MAIN() = takes(0) returns(0) {

  // extracting the function-selector

  0x00                  // [0]
  calldataload          // [calldata]
  0xe0                  // [0xe0, calldata]
  shr                   // [function_selector]

  // jumping to the correct function based on the selector

  dup1                  // [function_selector, function_selector]
  __FUNC_SIG(updateHorseNumber)            // [0xcdfead2e, function_selector, function_selector]
  eq                    // [true_if_selector_matches, function_selector]
  updateJump            // [updateHorseNumber_program_counter, true_if_selector_matches, function_selector]
  jumpi                 // [function_selector] {if the above condition is true then stack is empty and we jump to the updateJump counter}

  __FUNC_SIG(readNumberOfHorses)            // [0xe026c017, function_selector]
  eq                    // [true_if_selector_matches]
  readJump              // [readHorseNumber_program_counter, true_if_selector_matches]
  jumpi                 // {if the above condition is true then stack is empty and we jump to the readJump counter}


  0x00 0x00 revert      // here revert if no function-selector matches

  updateJump:
    SET_NUMBER_OF_HORSES()

  readJump:
    READ_NUMBER_OF_HORSES()
}

#define macro SET_NUMBER_OF_HORSES() = takes(0) returns(0){}

#define macro READ_NUMBER_OF_HORSES() = takes(0) returns(0){}